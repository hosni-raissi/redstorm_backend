package exploitation

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"time"

	"github.com/spf13/cobra"
)

/* ---------- data models ---------- */
type MetasploitResult struct {
	Target     string           `json:"target"`
	Exploits   []ExploitInfo    `json:"exploits"`
	Payloads   []PayloadInfo    `json:"payloads"`
	Simulation SimulationResult `json:"simulation"`
	Status     string           `json:"status"`
	Timestamp  string           `json:"timestamp"`
}

type ExploitInfo struct {
	Name        string   `json:"name"`
	CVE         string   `json:"cve"`
	Rank        string   `json:"rank"`
	Platform    string   `json:"platform"`
	Targets     []string `json:"targets"`
	Description string   `json:"description"`
}

type PayloadInfo struct {
	Name        string `json:"name"`
	Platform    string `json:"platform"`
	Arch        string `json:"arch"`
	Description string `json:"description"`
}

type SimulationResult struct {
	Exploitable        bool     `json:"exploitable"`
	SuccessProbability float64  `json:"success_probability"`
	ImpactLevel        string   `json:"impact_level"`
	Recommendations    []string `json:"recommendations"`
}

/* ---------- cobra command ---------- */
func NewExploitCommand() *cobra.Command {
	var (
		target  string
		service string
	)
	cmd := &cobra.Command{
		Use:   "exploit",
		Short: "Metasploit-based exploitation simulation (read-only, top-tier only)",
		Run: func(cmd *cobra.Command, args []string) {
			if target == "" {
				fmt.Fprintln(os.Stderr, "❗  -t <target> required")
				os.Exit(1)
			}
			res := performMetasploitAnalysis(target, service)
			outputJSON(res)
		},
	}
	cmd.Flags().StringVarP(&target, "target", "t", "", "target IP or domain")
	cmd.Flags().StringVarP(&service, "service", "s", "http", "target service (ssh, http, smb, …)")
	return cmd
}

/* ---------- business logic ---------- */
func performMetasploitAnalysis(target, service string) MetasploitResult {
	res := MetasploitResult{
		Target:    target,
		Status:    "running",
		Timestamp: time.Now().Format(time.RFC3339),
	}

	// 1. search exploits
	allExploits := searchExploits(target, service)
	var filtered []ExploitInfo
	for _, e := range allExploits {
		if e.Rank == "excellent" || e.Rank == "great" {
			filtered = append(filtered, e)
		}
	}
	res.Exploits = filtered

	// 2. search payloads
	res.Payloads = searchPayloads(service)

	// 3. simulation
	res.Simulation = simulateExploitation(target, service, res.Exploits)
	res.Status = "simulation_completed"
	return res
}

/* ---------- exploit search ---------- */
func searchExploits(target, service string) []ExploitInfo {
	// CI fallback
	if !inPATH("msfconsole") {
		return []ExploitInfo{
			{
				Name:        "exploit/multi/http/dummy",
				CVE:         "CVE-2024-0000",
				Rank:        "excellent",
				Platform:    "multi",
				Targets:     []string{"Dummy target"},
				Description: "Dummy exploit for CI pipelines",
			},
		}
	}

	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()

	search := fmt.Sprintf("search type:exploit name:%s", service)
	cmd := exec.CommandContext(ctx, "msfconsole", "-q", "-x", search+"; exit")
	out, err := cmd.Output()
	if err != nil {
		fmt.Fprintf(os.Stderr, "msfconsole search error: %v\n", err)
		return nil
	}

	var exploits []ExploitInfo
	lines := strings.Split(string(out), "\n")
	for _, raw := range lines {
		line := stripAnsi(raw)
		if !strings.Contains(line, "exploit/") {
			continue
		}
		parts := strings.Fields(line)
		modIdx := -1
		for i, p := range parts {
			if strings.HasPrefix(p, "exploit/") {
				modIdx = i
				break
			}
		}
		if modIdx == -1 || len(parts) < modIdx+3 {
			continue
		}
		name := parts[modIdx]
		rank := parts[modIdx+2]
		cve := findCVE(name)
		exploits = append(exploits, ExploitInfo{
			Name:        name,
			CVE:         cve,
			Rank:        rank,
			Platform:    extractPlatform(name),
			Targets:     nil, // could parse later
			Description: strings.Join(parts[modIdx+3:], " "),
		})
	}
	return exploits
}

/* ---------- payload search ---------- */
func searchPayloads(service string) []PayloadInfo {
	// CI fallback
	if !inPATH("msfconsole") {
		return []PayloadInfo{
			{
				Name:        "payload/generic/http_reverse",
				Platform:    "multi",
				Arch:        "generic",
				Description: "Dummy payload for CI pipelines",
			},
		}
	}

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	platform := extractPlatform(service)
	search := fmt.Sprintf("search type:payload platform:%s", platform)
	cmd := exec.CommandContext(ctx, "msfconsole", "-q", "-x", search+"; exit")
	out, err := cmd.Output()
	if err != nil {
		fmt.Fprintf(os.Stderr, "msfconsole payload search error: %v\n", err)
		return nil
	}

	var payloads []PayloadInfo
	lines := strings.Split(string(out), "\n")
	for _, raw := range lines {
		line := stripAnsi(raw)
		if !strings.Contains(line, "payload/") {
			continue
		}
		parts := strings.Fields(line)
		modIdx := -1
		for i, p := range parts {
			if strings.HasPrefix(p, "payload/") {
				modIdx = i
				break
			}
		}
		if modIdx == -1 || len(parts) < modIdx+2 {
			continue
		}
		name := parts[modIdx]
		payloads = append(payloads, PayloadInfo{
			Name:        name,
			Platform:    extractPlatform(name),
			Arch:        extractArch(name),
			Description: strings.Join(parts[modIdx+2:], " "),
		})
	}
	return payloads
}

/* ---------- simulation ---------- */
func simulateExploitation(target, service string, exploits []ExploitInfo) SimulationResult {
	sim := SimulationResult{
		Exploitable:        false,
		SuccessProbability: 0,
		ImpactLevel:        "low",
		Recommendations:    []string{},
	}
	if len(exploits) == 0 {
		return sim
	}
	sim.Exploitable = true

	good := 0
	for _, e := range exploits {
		if e.Rank == "excellent" || e.Rank == "great" {
			good++
		}
	}
	sim.SuccessProbability = float64(good) / float64(len(exploits)) * 100

	switch {
	case sim.SuccessProbability > 70:
		sim.ImpactLevel = "critical"
	case sim.SuccessProbability > 40:
		sim.ImpactLevel = "high"
	case sim.SuccessProbability > 20:
		sim.ImpactLevel = "medium"
	}

	sim.Recommendations = []string{
		"Update the vulnerable service to the latest version",
		"Implement network segmentation to limit exposure",
		"Enable intrusion-detection systems",
		"Apply security patches immediately",
		"Review and harden service configurations",
	}
	return sim
}

/* ---------- small helpers ---------- */
func stripAnsi(s string) string {
	re := regexp.MustCompile(`\x1b\[[0-9;]*m`)
	return re.ReplaceAllString(s, "")
}

func findCVE(path string) string {
	re := regexp.MustCompile(`(?i)cve[-_]20\d{2}[-_]\d{4,}`)
	if m := re.FindString(path); m != "" {
		return strings.ToUpper(strings.ReplaceAll(m, "_", "-"))
	}
	return ""
}

func extractPlatform(name string) string {
	switch {
	case strings.Contains(name, "linux"):
		return "linux"
	case strings.Contains(name, "windows"):
		return "windows"
	case strings.Contains(name, "unix"):
		return "unix"
	case strings.Contains(name, "android"):
		return "android"
	case strings.Contains(name, "osx") || strings.Contains(name, "mac"):
		return "macos"
	}
	return "multi"
}

func extractArch(name string) string {
	switch {
	case strings.Contains(name, "x64") || strings.Contains(name, "x86_64"):
		return "x64"
	case strings.Contains(name, "x86"):
		return "x86"
	case strings.Contains(name, "aarch64"):
		return "aarch64"
	}
	return "generic"
}

func inPATH(bin string) bool {
	_, err := exec.LookPath(bin)
	return err == nil
}

func outputJSON(v interface{}) {
	b, _ := json.MarshalIndent(v, "", "  ")
	fmt.Println(string(b))
}