// pkg/vulnerability/wpscan.go
package vulnerability

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"os/exec"
	"os"
	"time"

	"github.com/spf13/cobra"
)

/* ---------- WPScan-specific structs (unique names) ---------- */
type WPScanStatus struct {
	State   string `json:"state"`
	Meaning string `json:"meaning"`
}
type WPScanResult struct {
	Status   WPScanStatus `json:"status"`
	Findings []string     `json:"findings"`
}

/* ---------- public command ---------- */
func NewWPScanCommand() *cobra.Command {
	var target string
	cmd := &cobra.Command{
		Use:   "wpscan",
		Short: "WPScan full scan (Docker wrapper, token auto-validated)",
		Run: func(cmd *cobra.Command, args []string) {
			if target == "" {
				fmt.Println("‚ùó  -t <target> required")
				os.Exit(1)
			}
			res := RunWPScan(target)
			out, _ := json.MarshalIndent(res, "", "  ")
			fmt.Println(string(out))
		},
	}
	cmd.Flags().StringVarP(&target, "target", "t", "", "Target URL")
	return cmd
}

/* ---------- public runner ---------- */
const apiToken = "y4xnT0olcSC6rl0WFN27l6nxByP1mlqRjRTAfqZ6K1ag"

func RunWPScan(target string) WPScanResult {
	fmt.Println("WPScan    : validating API token ‚Ä¶")
	useAPI := isTokenValid(apiToken)
	if useAPI {
		fmt.Println("WPScan    : using API for full enumeration")
	} else {
		fmt.Println("WPScan    : fallback to passive enumeration (API token invalid)")
	}

	fmt.Println("WPScan    : starting ‚Ä¶")
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Minute)
	defer cancel()

	args := []string{"run", "--rm", "wpscanteam/wpscan",
		"--url", target, "--format", "json", "--no-banner", "--random-user-agent",
		"--detection-mode", "passive"}
	if useAPI {
		args = append(args, "--api-token", apiToken, "--enumerate", "ap,vt,tt,cb,dbe,u1-10")
	} else {
		args = append(args, "--enumerate", "p,vt,tt,cb,u1-5") // passive only
	}

	cmd := exec.CommandContext(ctx, "docker", args...)
	out, err := cmd.Output()
	if err != nil {
		fmt.Println("WPScan    : finished (error)")
		return WPScanResult{Status: WPScanStatus{State: "error", Meaning: fmt.Sprintf("WPScan exit: %v", err)}}
	}

	var m map[string]interface{}
	_ = json.Unmarshal(out, &m)
	var findings []string

	// theme
	if main, ok := m["main_theme"].(map[string]interface{}); ok {
		findings = append(findings, fmt.Sprintf("theme: %s (%s)", str(main["location"]), str(main["version"])))
	}
	// WP version
	if version, ok := m["version"].(map[string]interface{}); ok {
		findings = append(findings, fmt.Sprintf("WP version: %s", str(version["number"])))
	}
	// plugins
	if plugins, ok := m["plugins"].(map[string]interface{}); ok && len(plugins) > 0 {
		//  list every plugin
		for name := range plugins {
			findings = append(findings, fmt.Sprintf("Plugin: %s", name))
		}
	}
	// vulnerabilities via API
	if vulns, ok := m["vulnerabilities"].([]interface{}); ok && len(vulns) > 0 {
		findings = append(findings, fmt.Sprintf("üîì %d vulnerabilities found via API", len(vulns)))
	}
	// users
	if users, ok := m["users"].([]interface{}); ok && len(users) > 0 {
		findings = append(findings, fmt.Sprintf("üë§ %d users enumerated", len(users)))
	}
	if len(findings) == 0 {
		findings = append(findings, "No WP-specific findings")
	}
	fmt.Printf("WPScan    : finished (%d findings)\n", len(findings))
	return WPScanResult{
		Status:   WPScanStatus{State: "completed", Meaning: fmt.Sprintf("WPScan finished (%d findings)", len(findings))},
		Findings: findings,
	}
}

/* ---------- token validator ---------- */
func isTokenValid(token string) bool {
	if token == "" {
		return false
	}
	url := "https://wpscan.com/api/v3/wordpresses/494"
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return false
	}
	req.Header.Set("Authorization", fmt.Sprintf("Token token=%s", token))
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return false
	}
	defer resp.Body.Close()
	return resp.StatusCode == 200
}

