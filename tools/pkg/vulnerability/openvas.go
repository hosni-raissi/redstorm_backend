package vulnerability

import (
	"bytes"
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"time"

	"github.com/spf13/cobra"
)

/* ---------- OpenVAS-specific structs ---------- */
type OpenVASStatus struct {
	State   string `json:"state"`
	Meaning string `json:"meaning"`
}
type OpenVASResult struct {
	Status OpenVASStatus `json:"status"`
	Report string        `json:"report"` // base64 encoded XML when successful
}

/* ---------- public cobra command ---------- */
func NewOpenVASCommand() *cobra.Command {
	var target string
	cmd := &cobra.Command{
		Use:   "openvas",
		Short: "OpenVAS fully-automated scan (Docker wrapper)",
		Run: func(cmd *cobra.Command, args []string) {
			if target == "" {
				fmt.Println("❗  -t <target> required")
				os.Exit(1)
			}
			res := RunOpenVAS(target)
			out, _ := json.MarshalIndent(res, "", "  ")
			fmt.Println(string(out))
		},
	}
	cmd.Flags().StringVarP(&target, "target", "t", "", "hostname or IP to scan")
	return cmd
}

/* ---------- main runner ---------- */
const (
	webUI         = "https://localhost:9392"
	gmpEndpoint   = webUI + "/gmp"
	containerName = "openvas-container"
	image         = "securecompliance/gvm:latest"
	adminUser     = "admin"
	adminPass     = "redstorm" // we force this
	configID      = "daba56c8-73ec-11df-a475-002264764cea" // "Full and fast"
)

func RunOpenVAS(target string) OpenVASResult {
	fmt.Println("OpenVAS: ensuring container …")
	startContainer()

	fmt.Println("OpenVAS: waiting for services to be ready …")
	waitForServices()

	fmt.Println("OpenVAS: setting admin password …")
	setAdminPassword()

	token := gmpLogin()
	if token == "" {
		return ovasErr("login failed")
	}

	targetID := gmpCreateTarget(token, target)
	if targetID == "" {
		return ovasErr("target creation failed")
	}

	taskID := gmpCreateTask(token, targetID, "auto-task-"+target)
	if taskID == "" {
		return ovasErr("task creation failed")
	}

	fmt.Println("OpenVAS: starting task …")
	gmpStartTask(token, taskID)

	reportID := gmpWaitTask(context.Background(), token, taskID)
	if reportID == "" {
		return ovasErr("task did not finish")
	}

	xmlB64 := gmpGetReport(token, reportID)
	return OpenVASResult{
		Status: OpenVASStatus{State: "completed", Meaning: "scan finished"},
		Report: xmlB64,
	}
}

/* ---------- helpers ---------- */
func ovasErr(msg string) OpenVASResult {
	return OpenVASResult{
		Status: OpenVASStatus{State: "error", Meaning: msg},
		Report: "",
	}
}

/* ---- container ---- */
func startContainer() {
	if err := exec.Command("docker", "inspect", "-f", "{{.State.Running}}", containerName).Run(); err == nil {
		fmt.Println("OpenVAS: re-using running container")
		return
	}
	_ = exec.Command("docker", "rm", "-f", containerName).Run()
	cmd := exec.Command("docker", "run", "-d",
		"--name", containerName,
		"--privileged",
		"-p", "9392:9392",
		"-e", "PASSWORD="+adminPass,
		image)
	if err := cmd.Run(); err != nil {
		fmt.Println("OpenVAS: docker run failed:", err)
		os.Exit(1)
	}
}

/* ---- wait until GSAD answers ---- */
func waitForServices() {
	client := &http.Client{
		Transport: &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}},
		Timeout:   5 * time.Second,
	}
	for {
		if resp, err := client.Get(webUI); err == nil {
			resp.Body.Close()
			if resp.StatusCode == 200 {
				fmt.Println("OpenVAS: UI ready")
				return
			}
		}
		fmt.Println("OpenVAS: waiting for UI …")
		time.Sleep(10 * time.Second)
	}
}

func setAdminPassword() {
	_ = exec.Command("docker", "exec", containerName,
		"gvmd", "--user="+adminUser, "--new-password="+adminPass).Run()
}

/* ---- GMP client ---- */
var gmpClient = &http.Client{
	Transport: &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}},
	Timeout:   15 * time.Second,
}

func gmpSend(xmlCmd string) ([]byte, error) {
	req, _ := http.NewRequest("POST", gmpEndpoint, strings.NewReader(xmlCmd))
	req.Header.Set("Content-Type", "application/xml")
	resp, err := gmpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	return io.ReadAll(resp.Body)
}

func gmpLogin() string {
	cmd := fmt.Sprintf(`<authenticate><credentials><username>%s</username><password>%s</password></credentials></authenticate>`, adminUser, adminPass)
	b, err := gmpSend(cmd)
	if err != nil {
		return ""
	}
	re := regexp.MustCompile(`<token>([a-z0-9\-]+)</token>`)
	m := re.FindSubmatch(b)
	if len(m) < 2 {
		return ""
	}
	return string(m[1])
}

func gmpCreateTarget(token, host string) string {
	cmd := fmt.Sprintf(`%s<create_target><name>auto-%s</name><hosts>%s</hosts></create_target>`, token, host, host)
	b, _ := gmpSend(cmd)
	re := regexp.MustCompile(`<create_target_response[^>]+id="([^"]+)"`)
	m := re.FindSubmatch(b)
	if len(m) < 2 {
		return ""
	}
	return string(m[1])
}

func gmpCreateTask(token, targetID, name string) string {
	cmd := fmt.Sprintf(`%s<create_task>
		<name>%s</name>
		<config id="%s"/>
		<target id="%s"/>
		</create_task>`, token, name, configID, targetID)
	b, _ := gmpSend(cmd)
	re := regexp.MustCompile(`<create_task_response[^>]+id="([^"]+)"`)
	m := re.FindSubmatch(b)
	if len(m) < 2 {
		return ""
	}
	return string(m[1])
}

func gmpStartTask(token, taskID string) {
	cmd := fmt.Sprintf(`%s<start_task task_id="%s"/>`, token, taskID)
	gmpSend(cmd)
}

func gmpWaitTask(ctx context.Context, token, taskID string) string {
	tick := time.NewTicker(15 * time.Second)
	defer tick.Stop()
	for {
		select {
		case <-ctx.Done():
			return ""
		case <-tick.C:
			cmd := fmt.Sprintf(`%s<get_tasks task_id="%s" details="1"/>`, token, taskID)
			b, _ := gmpSend(cmd)
			// Done ?
			if bytes.Contains(b, []byte(`<status>Done</status>`)) {
				re := regexp.MustCompile(`<last_report><report id="([^"]+)"`)
				m := re.FindSubmatch(b)
				if len(m) >= 2 {
					fmt.Println("OpenVAS: task finished")
					return string(m[1])
				}
			}
			fmt.Println("OpenVAS: task still running …")
		}
	}
}

func gmpGetReport(token, reportID string) string {
	cmd := fmt.Sprintf(`%s<get_reports report_id="%s" format_id="a994b278-1f62-11e1-96ac-406186ea4fc5" details="1"/>`, token, reportID)
	b, _ := gmpSend(cmd)
	re := regexp.MustCompile(`<report>([^<]+)</report>`)
	m := re.FindSubmatch(b)
	if len(m) < 2 {
		return ""
	}
	return string(m[1]) // base64 encoded XML
}