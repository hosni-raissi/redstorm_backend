//  pkg/vulnerability/nuclei.go
package vulnerability

import (
	"bufio"
	"context"
	"embed"
	"encoding/json"
	"fmt"
	"io"
	"io/fs"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/spf13/cobra"
)

//go:embed all:templates
var templatesFS embed.FS

/* ---------- data models ---------- */
type NucleiResult struct {
	Target          string        `json:"target"`
	Vulnerabilities []NucleiVuln  `json:"vulnerabilities"`
	Summary         NucleiSummary `json:"summary"`
	Status          string        `json:"status"`
}

type NucleiVuln struct {
	TemplateID  string `json:"template_id"`
	Name        string `json:"name"`
	Severity    string `json:"severity"`
	Description string `json:"description"`
	MatchedAt   string `json:"matched_at"`
}

type NucleiSummary struct {
	Total, Critical, High, Medium, Low, Info int
}

/* ---------- cobra command ---------- */
func NewNucleiCommand() *cobra.Command {
	var (
		target  string
		timeout time.Duration
	)
	cmd := &cobra.Command{
		Use:   "nuclei",
		Short: "Fast vulnerability scanner (Nuclei wrapper, embedded templates)",
		Run: func(cmd *cobra.Command, args []string) {
			if target == "" {
				fmt.Fprintln(os.Stderr, "‚ùó  -t <target> required")
				os.Exit(1)
			}
			res := RunNuclei(target, timeout)
			out, _ := json.MarshalIndent(res, "", "  ")
			fmt.Println(string(out))
		},
	}
	cmd.Flags().StringVarP(&target, "target", "t", "", "Target URL")
	cmd.Flags().DurationVar(&timeout, "timeout", 3*time.Minute, "Max scan time (e.g. 2m, 30s)")
	return cmd
}

/* ---------- runner ---------- */
func RunNuclei(target string, timeout time.Duration) NucleiResult {
	res := NucleiResult{Target: target, Status: "running"}

	// 1. extract embedded templates to temp dir
	templatesDir, err := extractTemplates()
	if err != nil {
		res.Status = "error"
		res.Vulnerabilities = []NucleiVuln{{Name: "Embed Error", Severity: "info", Description: err.Error()}}
		return res
	}
	defer os.RemoveAll(templatesDir)

	// 2. locate nuclei binary
	bin, _ := exec.LookPath("nuclei")
	if bin == "" {
		bin = "./nuclei" // fallback
	}

	// 3. build command
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()

	args := []string{
		"-u", target,
		"-jsonl", "-silent",
		"-severity", "info,low,medium,high,critical",
		"-t", templatesDir,
		"-c", "25",
		"-rl", "150",
		"-timeout", "7",
		"-no-interactsh",
		"-disable-update-check",
		"-no-stdin",
	}

	cmd := exec.CommandContext(ctx, bin, args...)
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		res.Status = "error"
		res.Vulnerabilities = []NucleiVuln{{Name: "Pipe Error", Severity: "info", Description: err.Error()}}
		return res
	}
	stderr, _ := cmd.StderrPipe()

	if err := cmd.Start(); err != nil {
		res.Status = "error"
		res.Vulnerabilities = []NucleiVuln{{Name: "Start Error", Severity: "info", Description: err.Error()}}
		return res
	}

	// drain stderr in background (shows loader messages)
	go io.Copy(io.Discard, stderr)

	// stream JSON lines
	scanner := bufio.NewScanner(stdout)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}
		var m map[string]interface{}
		if err := json.Unmarshal([]byte(line), &m); err != nil {
			continue
		}
		v := NucleiVuln{
			TemplateID:  str(m["template-id"]),
			Name:        str(m["info.name"]),
			Severity:    str(m["info.severity"]),
			Description: str(m["info.description"]),
			MatchedAt:   str(m["matched-at"]),
		}
		// fallback for templates that leave fields empty
		if v.Severity == "" {
			v.Severity = "info"
		}
		if v.Name == "" {
			v.Name = v.TemplateID
		}
		res.Vulnerabilities = append(res.Vulnerabilities, v)
		res.Summary.Total++
		switch strings.ToLower(v.Severity) {
		case "critical":
			res.Summary.Critical++
		case "high":
			res.Summary.High++
		case "medium":
			res.Summary.Medium++
		case "low":
			res.Summary.Low++
		default: // info or empty
			res.Summary.Info++
		}
	}

	// wait for completion or timeout
	if err := cmd.Wait(); err != nil {
		if ctx.Err() == context.DeadlineExceeded {
			res.Status = "timeout"
		} else {
			res.Status = "error"
			res.Vulnerabilities = append(res.Vulnerabilities,
				NucleiVuln{Name: "Exit Error", Severity: "info", Description: err.Error()})
		}
	} else {
		res.Status = "completed"
	}
	return res
}

/* ---------- helpers ---------- */
func str(v interface{}) string {
	if s, ok := v.(string); ok {
		return s
	}
	return ""
}

func extractTemplates() (string, error) {
	tmpDir, err := os.MkdirTemp("", "nuclei-templates-*")
	if err != nil {
		return "", err
	}
	// replicate embedded tree to disk
	err = fs.WalkDir(templatesFS, "templates", func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		target := filepath.Join(tmpDir, path)
		if d.IsDir() {
			return os.MkdirAll(target, 0755)
		}
		data, err := templatesFS.ReadFile(path)
		if err != nil {
			return err
		}
		return os.WriteFile(target, data, 0644)
	})
	if err != nil {
		os.RemoveAll(tmpDir)
		return "", err
	}
	return filepath.Join(tmpDir, "templates"), nil
}