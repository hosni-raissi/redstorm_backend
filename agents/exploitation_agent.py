"""
Exploitation Agent - Ethical exploitation simulation and impact assessment
"""
import asyncio
import json
import subprocess
import functools
from pathlib import Path
from typing import Dict, Any, List
from datetime import datetime
from .base_agent import BaseAgent

_TOOL_DIR = Path(__file__).resolve().parent.parent / "tools"
_REDSTORM_TOOLS = _TOOL_DIR / "redstorm-tools"


class ExploitationAgent(BaseAgent):
    def __init__(self):
        super().__init__(
            name="exploitation",
            description="Ethical exploitation simulation and impact assessment"
        )

    async def execute(self, target: str, options: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute exploitation simulation phase"""
        options = options or {}
        if not await self.validate_target(target):
            return {"error": "Invalid target"}

        self.status = "running"
        ws = options.get("websocket_manager")
        cid = options.get("client_id")

        # ---- original skeleton ----
        results = {
            "target": target,
            "phase": "exploitation",
            "simulated_exploits": [],
            "attack_vectors": [],
            "impact_assessment": {},
            "post_exploitation": {},
            "ethical_disclaimer": "All exploitation activities are simulated for security assessment purposes only"
        }

        try:
            # 1. call the Go wrapper and merge its real results
            await self.send_update(ws, cid, {"status": "exploitation", "message": "Running exploitation simulation…"})
            raw = await self._exec_exploit(target, options)
            if raw.get("error"):
                return raw

            results["exploits"] = raw.get("exploits", [])
            results["payloads"] = raw.get("payloads", [])
            results["simulation"] = raw.get("simulation", {})

            # 2. keep your original pure-python simulations as **fallback** when wrapper returns empty
            if not results["exploits"]:
                await self.send_update(ws, cid, {"status": "simulating_exploits", "message": "Running pure-python fallback simulation…"})
                results["attack_vectors"] = await self.analyze_attack_vectors(target, options)
                results["simulated_exploits"] = await self.simulate_exploits(results["attack_vectors"])
                results["impact_assessment"] = await self.assess_impact(results["simulated_exploits"])
                results["post_exploitation"] = await self.simulate_post_exploitation(results["simulated_exploits"])

            self.status = "completed"
            return results

        except Exception as e:
            self.status = "error"
            self.log_activity(f"Exploitation simulation error: {str(e)}", "error")
            return {"error": str(e)}

    # ----------------------------------------------------------
    # private helper: call the Go wrapper with -t <target> -s <service>
    # ----------------------------------------------------------
    async def _exec_exploit(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        service = options.get("service", "http")          # <-- new flag
        cmd = [_REDSTORM_TOOLS, "exploit", "-t", target, "-s", service]
        proc = await asyncio.create_subprocess_exec(
            *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.DEVNULL
        )
        stdout, _ = await proc.communicate()

        # strip banners / colours
        json_start = stdout.find(b'{')
        if json_start == -1:
            return {"error": "No JSON object returned from exploitation wrapper"}

        try:
            return json.loads(stdout[json_start:])
        except Exception as e:
            return {"error": f"Bad JSON from wrapper: {e}"}

    # ------------------------------------------------------------------
    #  ALL ORIGINAL SIMULATION METHODS UNTOUCHED BELOW
    # ------------------------------------------------------------------
    async def analyze_attack_vectors(self, target: str, options: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Analyze potential attack vectors based on previous findings"""
        attack_vectors = []
        previous_results = options.get("previous_results", {})
        vulnerabilities = previous_results.get("vulnerability", {}).get("vulnerabilities", [])
        open_ports = previous_results.get("scanning", {}).get("open_ports", [])

        web_ports = [port for port in open_ports if port.get("port") in [80, 443, 8080, 8443]]
        if web_ports:
            attack_vectors.extend(await self.analyze_web_vectors(target, vulnerabilities))

        network_vectors = await self.analyze_network_vectors(open_ports, vulnerabilities)
        attack_vectors.extend(network_vectors)

        social_vectors = await self.analyze_social_vectors(target)
        attack_vectors.extend(social_vectors)
        return attack_vectors

    async def analyze_web_vectors(self, target: str, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Analyze web application attack vectors"""
        web_vectors = []
        web_vulns = [v for v in vulnerabilities if any(web_type in v.get("name", "").lower()
                    for web_type in ["xss", "sql", "csrf", "lfi", "rfi", "ssrf"])]
        for vuln in web_vulns:
            web_vectors.append({
                "type": "web_application",
                "name": vuln.get("name", "Unknown Web Vulnerability"),
                "severity": vuln.get("severity", "medium"),
                "description": vuln.get("description", ""),
                "attack_complexity": self.assess_attack_complexity(vuln),
                "success_probability": self.calculate_success_probability(vuln),
                "required_skills": self.determine_required_skills(vuln),
                "detection_likelihood": self.assess_detection_likelihood(vuln)
            })

        common_web_vectors = [
            {
                "type": "web_application",
                "name": "Brute Force Authentication",
                "severity": "medium",
                "description": "Attempt to brute force login credentials",
                "attack_complexity": "low",
                "success_probability": 0.3,
                "required_skills": "beginner",
                "detection_likelihood": "high"
            },
            {
                "type": "web_application",
                "name": "Directory Traversal",
                "severity": "medium",
                "description": "Attempt to access files outside web root",
                "attack_complexity": "low",
                "success_probability": 0.4,
                "required_skills": "beginner",
                "detection_likelihood": "medium"
            }
        ]
        web_vectors.extend(common_web_vectors)
        return web_vectors

    async def analyze_network_vectors(self, open_ports: List[Dict[str, Any]], vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Analyze network service attack vectors"""
        network_vectors = []
        for port in open_ports:
            if port.get("state") == "open":
                service = port.get("service", "unknown")
                port_num = port.get("port")

                if service.lower() == "ssh" or port_num == 22:
                    network_vectors.append({
                        "type": "network_service",
                        "name": "SSH Brute Force",
                        "severity": "high",
                        "description": f"Brute force attack against SSH service on port {port_num}",
                        "attack_complexity": "medium",
                        "success_probability": 0.2,
                        "required_skills": "intermediate",
                        "detection_likelihood": "high"
                    })

                if service.lower() == "ftp" or port_num == 21:
                    network_vectors.append({
                        "type": "network_service",
                        "name": "FTP Anonymous Access",
                        "severity": "medium",
                        "description": f"Check for anonymous FTP access on port {port_num}",
                        "attack_complexity": "low",
                        "success_probability": 0.6,
                        "required_skills": "beginner",
                        "detection_likelihood": "low"
                    })

                if any(db in service.lower() for db in ["mysql", "postgresql", "mongodb"]):
                    network_vectors.append({
                        "type": "network_service",
                        "name": "Database Brute Force",
                        "severity": "high",
                        "description": f"Brute force attack against {service} database",
                        "attack_complexity": "medium",
                        "success_probability": 0.3,
                        "required_skills": "intermediate",
                        "detection_likelihood": "high"
                    })
        return network_vectors

    async def analyze_social_vectors(self, target: str) -> List[Dict[str, Any]]:
        """Analyze social engineering attack vectors"""
        return [
            {
                "type": "social_engineering",
                "name": "Phishing Campaign",
                "severity": "high",
                "description": "Targeted phishing emails to employees",
                "attack_complexity": "medium",
                "success_probability": 0.7,
                "required_skills": "intermediate",
                "detection_likelihood": "medium"
            },
            {
                "type": "social_engineering",
                "name": "Pretexting",
                "severity": "medium",
                "description": "Phone-based social engineering attacks",
                "attack_complexity": "high",
                "success_probability": 0.5,
                "required_skills": "advanced",
                "detection_likelihood": "low"
            }
        ]

    async def simulate_exploits(self, attack_vectors: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Simulate exploitation attempts (ethical simulation only)"""
        simulated_exploits = []
        for vector in attack_vectors:
            simulated_exploits.append({
                "vector": vector["name"],
                "type": vector["type"],
                "severity": vector["severity"],
                "simulation_status": "simulated",
                "success_probability": vector.get("success_probability", 0.5),
                "simulated_outcome": self.simulate_exploit_outcome(vector),
                "time_to_exploit": self.estimate_time_to_exploit(vector),
                "tools_required": self.identify_required_tools(vector),
                "countermeasures": self.suggest_countermeasures(vector)
            })
            await asyncio.sleep(0.5)
        return simulated_exploits

    def simulate_exploit_outcome(self, vector: Dict[str, Any]) -> Dict[str, Any]:
        import random
        success_prob = vector.get("success_probability", 0.5)
        success = random.random() < success_prob
        outcome = {
            "success": success,
            "confidence": "simulation",
            "impact_level": vector.get("severity", "medium"),
            "access_gained": [],
            "data_at_risk": [],
            "lateral_movement_potential": "unknown"
        }
        if success:
            if vector["type"] == "web_application":
                outcome["access_gained"] = ["web_application_access", "potential_database_access"]
                outcome["data_at_risk"] = ["user_credentials", "application_data"]
            elif vector["type"] == "network_service":
                outcome["access_gained"] = ["service_access", "potential_system_access"]
                outcome["data_at_risk"] = ["system_files", "network_access"]
            elif vector["type"] == "social_engineering":
                outcome["access_gained"] = ["user_credentials", "internal_access"]
                outcome["data_at_risk"] = ["email_access", "internal_systems"]
            outcome["lateral_movement_potential"] = "high" if vector.get("severity") == "high" else "medium"
        return outcome

    def estimate_time_to_exploit(self, vector: Dict[str, Any]) -> str:
        complexity = vector.get("attack_complexity", "medium")
        return {"low": "< 1 hour", "medium": "1-4 hours", "high": "1-3 days"}.get(complexity, "unknown")

    def identify_required_tools(self, vector: Dict[str, Any]) -> List[str]:
        vector_type = vector.get("type", "")
        if vector_type == "web_application":
            return ["Burp Suite", "OWASP ZAP", "SQLMap", "Custom Scripts"]
        elif vector_type == "network_service":
            return ["Nmap", "Metasploit", "Hydra", "Custom Exploits"]
        elif vector_type == "social_engineering":
            return ["Social Engineering Toolkit", "Email Templates", "Phone Scripts"]
        return ["Custom Tools"]

    def suggest_countermeasures(self, vector: Dict[str, Any]) -> List[str]:
        vector_type = vector.get("type", "")
        if vector_type == "web_application":
            return ["Input validation and sanitization", "Web Application Firewall (WAF)", "Regular security testing", "Secure coding practices"]
        elif vector_type == "network_service":
            return ["Network segmentation", "Strong authentication", "Regular patching", "Intrusion detection systems"]
        elif vector_type == "social_engineering":
            return ["Security awareness training", "Email filtering", "Multi-factor authentication", "Incident response procedures"]
        return ["General security hardening"]

    async def assess_impact(self, simulated_exploits: List[Dict[str, Any]]) -> Dict[str, Any]:
        successful = [e for e in simulated_exploits if e.get("simulated_outcome", {}).get("success")]
        assessment = {
            "overall_impact": "medium",
            "confidentiality_impact": "medium",
            "integrity_impact": "medium",
            "availability_impact": "low",
            "business_impact": {},
            "compliance_impact": {},
            "financial_impact": {}
        }
        if successful:
            data_at_risk = set()
            for e in successful:
                data_at_risk.update(e.get("simulated_outcome", {}).get("data_at_risk", []))
            if "user_credentials" in data_at_risk or "system_files" in data_at_risk:
                assessment["confidentiality_impact"] = "high"
            access_gained = set()
            for e in successful:
                access_gained.update(e.get("simulated_outcome", {}).get("access_gained", []))
            if "system_access" in access_gained or "database_access" in access_gained:
                assessment["integrity_impact"] = "high"
            assessment["business_impact"] = {
                "reputation_damage": "medium",
                "operational_disruption": "low",
                "customer_trust": "medium",
                "competitive_advantage": "low"
            }
            assessment["compliance_impact"] = {
                "gdpr_violation_risk": "medium" if "user_credentials" in data_at_risk else "low",
                "pci_dss_risk": "medium" if "payment_data" in data_at_risk else "low",
                "hipaa_risk": "low"
            }
            assessment["financial_impact"] = {
                "estimated_cost_range": "$10,000 - $100,000",
                "factors": ["Incident response costs", "System recovery", "Regulatory fines", "Business disruption"]
            }
        return assessment

    async def simulate_post_exploitation(self, simulated_exploits: List[Dict[str, Any]]) -> Dict[str, Any]:
        successful = [e for e in simulated_exploits if e.get("simulated_outcome", {}).get("success")]
        post_exploitation = {
            "persistence_mechanisms": [],
            "privilege_escalation": {},
            "lateral_movement": {},
            "data_exfiltration": {},
            "cleanup_activities": []
        }
        if successful:
            post_exploitation["persistence_mechanisms"] = [
                {"method": "Web Shell", "description": "Deploy web shell for persistent access", "detection_difficulty": "medium", "persistence_level": "application"},
                {"method": "Scheduled Task", "description": "Create scheduled task for persistence", "detection_difficulty": "low", "persistence_level": "system"}
            ]
            post_exploitation["privilege_escalation"] = {
                "potential_methods": ["Kernel exploits", "Service misconfigurations", "Weak file permissions"],
                "success_probability": 0.4,
                "target_privileges": "administrator/root"
            }
            post_exploitation["lateral_movement"] = {
                "potential_targets": ["Internal web servers", "Database servers", "File servers"],
                "movement_techniques": ["Credential reuse", "Network scanning", "Service exploitation"],
                "network_reach": "subnet"
            }
            post_exploitation["data_exfiltration"] = {
                "target_data": ["User databases", "Configuration files", "Application source code"],
                "exfiltration_methods": ["HTTP/HTTPS tunneling", "DNS tunneling", "Email attachments"],
                "detection_likelihood": "medium"
            }
            post_exploitation["cleanup_activities"] = [
                "Remove uploaded files", "Clear access logs", "Remove persistence mechanisms", "Restore original configurations"
            ]
        return post_exploitation