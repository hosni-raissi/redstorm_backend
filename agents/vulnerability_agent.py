"""
Vulnerability Agent – parallel launcher for Nuclei, OpenVAS, WPScan, ZAP
(crash-safe, relative paths, same merge pattern as ReconnaissanceAgent)
"""
import asyncio
import json
import subprocess
from pathlib import Path
from typing import Dict, Any, List
from datetime import datetime
from .base_agent import BaseAgent

_TOOL_DIR = Path(__file__).resolve().parent.parent / "tools"
_REDSTORM_TOOLS = _TOOL_DIR / "redstorm-tools"


class VulnerabilityAgent(BaseAgent):
    def __init__(self):
        super().__init__(
            name="vulnerability",
            description="Parallel vulnerability scanner (Nuclei, OpenVAS, WPScan, ZAP)"
        )

    # ----------------------------------------------------------
    # public API – identical signature to old agent
    # ----------------------------------------------------------
    async def execute(self, target: str, options: Dict[str, Any] = None) -> Dict[str, Any]:
        options = options or {}
        if not await self.validate_target(target):
            return {"error": "Invalid target"}

        self.status = "running"
        ws = options.get("websocket_manager")
        cid = options.get("client_id")

        # skeleton answer (same keys as legacy agent)
        results = {
            "target": target,
            "phase": "vulnerability",
            "vulnerabilities": [],
            "cve_matches": [],
            "security_issues": [],
            "risk_assessment": {},
            "recommendations": []
        }

        try:
            # 1. parallel tools
            raw = await self._run_all_tools(target, ws, cid)

            # 2. merge vulnerabilities (same pattern as recon)
            seen = set()
            for tool, payload in raw.items():
                if not isinstance(payload, dict):
                    continue
                vulns = payload.get("vulnerabilities", [])
                for v in (vulns if isinstance(vulns, list) else []):
                    uid = f"{tool}::{v.get('template_id','')}::{v.get('matched_at','')}"
                    if uid in seen:
                        continue
                    seen.add(uid)
                    # ensure required keys exist
                    v.setdefault("severity", "info")
                    v.setdefault("name", v.get("template_id", "unknown"))
                    results["vulnerabilities"].append(v)

            # 3. post-process exactly like legacy agent
            results["cve_matches"] = await self._analyze_cves(results["vulnerabilities"])
            results["security_issues"] = await self._security_config(target)
            results["risk_assessment"] = await self._risk_assessment(results)
            results["recommendations"] = await self._generate_recommendations(results)

            self.status = "completed"
            return results

        except Exception as e:
            self.status = "error"
            self.log_activity(f"Vulnerability assessment error: {str(e)}", "error")
            return {"error": str(e)}

    # ----------------------------------------------------------
    # 1. parallel tool launcher (crash-safe)
    # ----------------------------------------------------------
    async def _run_all_tools(self, target: str, ws, cid) -> Dict[str, Any]:
        configs = [
            ("nuclei",   ["nuclei",   "-t", target]),
            ("wpscan",   ["wpscan",   "-t", target]),
            ("zap",      ["zap",      "-t", target]),
            # ("openvas", ["openvas", "-t", target]),  # enable when ready
        ]
        tasks = [
            asyncio.create_task(self._exec_tool(name, target, ws, cid))
            for name, _ in configs
        ]
        gathered = await asyncio.gather(*tasks, return_exceptions=True)
        return {name: (payload if not isinstance(payload, Exception) else {})
                for name, payload in zip([c[0] for c in configs], gathered)}

    async def _exec_tool(self, name: str, target: str, ws, cid):
        key = f"vuln_{name}"
        await self.send_update(ws, cid, {"status": key, "message": f"Running {name}…"})

        cmd = [_REDSTORM_TOOLS, name, "-t", target]
        proc = await asyncio.create_subprocess_exec(
            *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.DEVNULL
        )
        stdout, _ = await proc.communicate()

        # strip everything before first '{' (progress text, banners, colours)
        json_start = stdout.find(b'{')
        if json_start == -1:
            self.log_activity(f"{name} no JSON object found", "warning")
            return {}
        try:
            return json.loads(stdout[json_start:])
        except Exception as e:
            self.log_activity(f"{name} bad JSON: {e}", "error")
            return {}

    # ----------------------------------------------------------
    # 2. post-processing helpers (same logic as legacy agent)
    # ----------------------------------------------------------
    async def _analyze_cves(self, vulns: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        cve_matches = []
        for v in vulns:
            tid = v.get("template_id", "").upper()
            if "CVE-" in tid:
                cve_id = tid.split("_")[0]
                cve_matches.append({
                    "cve_id": cve_id,
                    "cvss_score": 0.0,
                    "severity": v.get("severity", "info"),
                    "description": "",
                    "published_date": "",
                    "references": [],
                    "affected_template": tid
                })
        return cve_matches

    async def _security_config(self, target: str) -> List[Dict[str, Any]]:
        issues = []
        try:
            import requests
            resp = requests.get(f"https://{target}", timeout=8, verify=False)
            if "https" not in resp.url:
                issues.append({"type": "ssl_config", "issue": "No HTTPS redirect",
                               "severity": "medium", "description": "Site does not redirect HTTP to HTTPS"})
            if not resp.headers.get("X-Frame-Options"):
                issues.append({"type": "missing_header", "issue": "Missing X-Frame-Options",
                               "severity": "medium", "description": "Click-jacking protection absent"})
        except Exception:
            pass
        return issues

    async def _risk_assessment(self, results: Dict[str, Any]) -> Dict[str, Any]:
        counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        for v in results["vulnerabilities"]:
            counts[v.get("severity", "info").lower()] += 1
        for s in results["security_issues"]:
            counts[s.get("severity", "info").lower()] += 1

        score = counts["critical"] * 10 + counts["high"] * 7 + counts["medium"] * 4 + counts["low"]
        level = "low"
        if score >= 50:
            level = "critical"
        elif score >= 25:
            level = "high"
        elif score >= 10:
            level = "medium"

        return {
            "overall_risk_level": level,
            "risk_score": score,
            "severity_breakdown": counts,
            "total_issues": sum(counts.values()),
            "assessment_date": datetime.now().isoformat()
        }

    async def _generate_recommendations(self, results: Dict[str, Any]) -> List[Dict[str, Any]]:
        recs = []
        if results["risk_assessment"].get("overall_risk_level") in ("critical", "high"):
            recs.append({
                "priority": "critical",
                "category": "immediate_action",
                "title": "Immediate Security Review Required",
                "description": "Critical vulnerabilities detected. Immediate security review and patching required.",
                "action_items": ["Review all critical and high severity findings", "Apply security patches immediately"]
            })
        if any(i["type"] == "missing_header" for i in results["security_issues"]):
            recs.append({
                "priority": "medium",
                "category": "security_headers",
                "title": "Missing Security Headers",
                "description": "Important security headers are missing",
                "action_items": ["Implement Content Security Policy", "Add X-Frame-Options header"]
            })
        return recs